const express = require("express");
const router = express.Router();
const Offer = require("../models/Offer");
const auth = require("../middleware/auth");
const mongoose = require("mongoose");

// ===============================
// 1. Client → Send Offer
// ===============================
router.post("/", auth, async (req, res) => {
  const { candidateId,clientEmail,candidateEmail, jobId, preferredChargesType,serviceType,offeredSalary } = req.body;
  const clientId = req.user.id; // JWT se client

  if (!clientId || !candidateId) {
    return res.status(400).json({ error: "clientId (from token) and candidateId are required" });
  }

  try {
    const existingOffer = await Offer.findOne({ clientId,candidateEmail,clientEmail,candidateId,offeredSalary,preferredChargesType,serviceType, jobId });
    if (existingOffer) {
      return res.status(400).json({ error: "Offer already sent to this candidate" });
    }

    const newOffer = new Offer({
  clientId,
  clientEmail,
  candidateEmail,
  candidateId,
  jobId,
  
  preferredChargesType,
  serviceType,
  offeredSalary,   // initial client offer
  candidateRequestedSalary: 0, // initially 0
  clientCounterSalary: 0,      // initially 0
  finalSalary: 0,              // initially 0
  status: "Pending",
  negotiationCount: 0
});

await newOffer.save();
    res.status(201).json({ message: "Offer sent successfully", offer: newOffer });
  } catch (err) {
    console.error("Error creating offer:", err);
    res.status(500).json({ error: err.message });
  }
});
// ===============================
// 2. Candidate → Get All Received Offers
// ===============================
router.get("/candidate/offers", auth, async (req, res) => {
  try {
    const offers = await Offer.aggregate([
      // Match only offers for logged-in candidateconsole.log("Auth middleware user:", req.user);

      { $match: { candidateId: new mongoose.Types.ObjectId(req.user.id),
         status: { $nin:["Accepted","Closed"]  }   // ✅ immediately hide accepted offers
      } },
      
      // Join client collection
      {
        $lookup: {
          from: "clients",        // collection name in MongoDB
          localField: "clientId",
          foreignField: "_id",
          as: "client",
        },
      },
       { $unwind: { path: "$client", preserveNullAndEmptyArrays: true } },   // convert array to object

      // Join candidate collection
      {
        $lookup: {
          from: "candidates",     // collection name in MongoDB
          localField: "candidateId",
          foreignField: "_id",
          as: "candidate",
        },
      },
     { $unwind: { path: "$candidate", preserveNullAndEmptyArrays: true } },

      // Project only required fields
      {
        $project: {
          _id: 1,
          offeredSalary: 1,
          preferredChargesType: 1,
          serviceType: 1,
          candidateRequestedSalary: 1,
          clientCounterSalary: 1,
          status: 1,
          finalSalary: 1,  
          
          "client.name": 1,
          "client.email": 1,
          "client.serviceType": 1,
          "client.preferredChargesType": 1,
          "candidate.charges": 1,
          "candidate.name": 1,
          "candidate.email": 1,
        },
      },
    ]);
 console.log("Step 1 - after basic lookup:", offers);
   
    res.json(offers);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Server error" });
  }
});
// ===============================
// 3. Candidate → Negotiate Offer
// ===============================
// Candidate sends a counter-offer
router.post("/negotiate", auth, async (req, res) => {
  const { offerId, negotiatedSalary } = req.body; // negotiatedSalary = candidate's counter
  const candidateId = req.user.id;

  try {
    if (!offerId || negotiatedSalary === undefined) {
      return res.status(400).json({ error: "offerId and negotiatedSalary are required" });
    }

    const offer = await Offer.findById(offerId);
    if (!offer) return res.status(404).json({ error: "Offer not found" });

    if (offer.candidateId.toString() !== candidateId) {
      return res.status(403).json({ error: "Not authorized to negotiate this offer" });
    }

    // Negotiation limit
    if ((offer.negotiationCount || 0) >= 3) {
      return res.status(400).json({ error: "Maximum 3 negotiations allowed" });
    }

    // Save negotiation info
    offer.candidateRequestedSalary = negotiatedSalary; // candidate's requested amount
    offer.negotiatedSalary = negotiatedSalary;         // current negotiated amount
    offer.status = "Negotiating";
    offer.negotiationCount = (offer.negotiationCount || 0) + 1;

    await offer.save();

    res.json({ message: "Negotiation started", offer });
  } catch (err) {
    console.error("Error negotiating offer:", err);
    res.status(500).json({ error: err.message });
  }
});
// GET /api/offers/candidate/offers
// ===============================
// 4. Client → Get All Sent Offers
// ===============================
// routes/offers.js

router.get("/offers/client", auth, async (req, res) => {
  try {
    const clientId = req.user.id; // Logged-in client's ID

    const offers = await Offer.find({ clientId})
      .populate("clientId", "name email preferredChargesType serviceType")
      .populate("candidateId", "name email charges") // populate candidate info if needed
      .sort({ createdAt: -1 });

    // Map for frontend-friendly keys
    const formattedOffers = offers.map((o) => ({
      _id: o._id,
      client: o.clientId,
      candidate: o.candidateId,
      jobId: o.jobId,
      serviceType: o.serviceType,
      preferredChargesType: o.preferredChargesType,
      status: o.status,
      negotiationCount: o.negotiationCount,

      candidateRequestedSalary: o.candidateRequestedSalary || null,  // ✅ use this
      clientCounterSalary: o.clientCounterSalary || null,
      finalSalary: o.finalSalary || null,
      // removed negotiatedSalary field

      createdAt: o.createdAt,
    }));

    res.json(formattedOffers);
  } catch (err) {
    console.error("Error fetching offers:", err);
    res.status(500).json({ error: err.message });
  }
});

// ===============================
// 5. Candidate → Accept/Reject Offer
// ===============================
router.post("/decision", auth, async (req, res) => {
  const { offerId, decision } = req.body; // Accepted / Rejected
  const candidateId = req.user.id;

  try {
    const offer = await Offer.findById(offerId);
    if (!offer) return res.status(404).json({ error: "Offer not found" });
    if (offer.candidateId.toString() !== candidateId) {
      return res.status(403).json({ error: "Not authorized to update this offer" });
    }

    offer.status = decision;
    if (decision === "Rejected") {
      offer.finalSalary = null;
    }
    if (decision === "Accepted") {
      offer.finalSalary = offer.clientCounterSalary|| offer.negotiatedSalary || offer.offeredSalary;
    }

    await offer.save();
    res.json({ message: `Offer ${decision}`, offer });
  } catch (err) {
    console.error("Error updating decision:", err);
    res.status(500).json({ error: err.message });
  }
});

// ===============================
// 6. Client → Accept Negotiation
// ===============================
router.post("/accept-negotiation", auth, async (req, res) => {
  const { offerId } = req.body;
  const clientId = req.user.id;

  try {
    const offer = await Offer.findById(offerId);
    if (!offer) return res.status(404).json({ error: "Offer not found" });
    if (offer.clientId.toString() !== clientId) {
      return res.status(403).json({ error: "Not authorized to accept this negotiation" });
    }

    if (!offer.negotiatedSalary) {
      return res.status(400).json({ error: "No negotiation found to accept" });
    }

    offer.finalSalary = offer.negotiatedSalary;
    offer.status = "Accepted";
    await offer.save();

    res.json({ message: "Negotiation accepted", offer });
  } catch (err) {
    console.error("Error accepting negotiation:", err);
    res.status(500).json({ error: err.message });
  }
});

// ===============================
// 7. Get Offer Status
// ===============================
router.get("/status", auth, async (req, res) => {
  try {
    const { clientId, jobId } = req.query;
    const candidateId = req.user.id;

    const offer = await Offer.findOne({ clientId, candidateId, jobId });
    if (!offer) {
      return res.json({ status: "" });
    }

    res.json({ status: offer.status });
  } catch (err) {
    console.error("Error fetching offer status:", err);
    res.status(500).json({ error: err.message });
  }
});

// ===============================
// 8. Client → Respond to Negotiation (Counter / Accept / Reject)
// ===============================  
// ===============================
// Client → Respond to Candidate Negotiation
// ===============================
router.post("/:id/respond-negotiation", auth, async (req, res) => {
  try {
    const { decision, counterAmount } = req.body; // decision = "Counter" | "Accepted" | "Rejected"
    const offer = await Offer.findById(req.params.id);
    if (!offer) return res.status(404).json({ error: "Offer not found" });

    // Only client can respond
    if (offer.clientId.toString() !== req.user.id)
      return res.status(403).json({ error: "Unauthorized" });

    offer.negotiations = offer.negotiations || [];

    // -------------------------------
    // 1️⃣ Client sends Counter
    // -------------------------------
    if (decision === "Counter") {
      if (!counterAmount) return res.status(400).json({ error: "Counter amount is required" });

      offer.clientCounterSalary = counterAmount;
      offer.status = "Negotiating";
      offer.negotiationCount = (offer.negotiationCount || 0) + 1;

      offer.negotiations.push({
        by: "client",
        action: "Counter",
        salary: counterAmount,
        createdAt: new Date(),
      });
    } 
    // -------------------------------
    // 2️⃣ Client Accepts Candidate Proposal
    // -------------------------------
    else if (decision === "Accepted") {
      if (!offer.candidateRequestedSalary) {
        return res.status(400).json({ error: "No candidate negotiation to accept" });
      }

      // finalSalary = candidate requested salary
      offer.finalSalary = offer.candidateRequestedSalary;
      offer.status = "Accepted";

      offer.negotiations.push({
        by: "client",
        action: "Accepted",
        salary: offer.finalSalary,
        createdAt: new Date(),
      });
    } 
    // -------------------------------
    // 3️⃣ Client Rejects
    // -------------------------------
    else if (decision === "Rejected") {
      offer.status = "Rejected";
      offer.negotiations.push({
        by: "client",
        action: "Rejected",
        salary: null,
        createdAt: new Date(),
      });
    } 
    else {
      return res.status(400).json({ error: "Invalid decision" });
    }

    await offer.save();
    res.json({ message: `Negotiation ${decision}`, offer });

  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Server error" });
  }
});

// Candidate responds to negotiation
router.post("/:id/respond-negotiation-candidate", auth, async (req, res) => {
  const { decision, counterAmount } = req.body;
  const offer = await Offer.findById(req.params.id);
  if (!offer) return res.status(404).send("Offer not found");

  // Candidate check
  if (offer.candidateId.toString() !== req.user.id) return res.status(403).send("Unauthorized");

  if (decision === "Counter") {
    offer.negotiatedSalary = counterAmount;
    offer.status = "Negotiating";
    offer.negotiationCount += 1;
  } else if (decision === "Accepted") {
    offer.finalSalary = offer.negotiatedSalary||offer.candidateRequestedSalary || offer.offeredSalary;
    offer.status = "Accepted";
  } else if (decision === "Rejected") {
    offer.status = "Rejected";
  }

  await offer.save();
  res.json(offer);
});

// ===============================
// 9. Client → Set/Update End Date
// ===============================
router.post("/:id/enddate", auth, async (req, res) => {
  try {
    const offerId = req.params.id;
    const { endDate } = req.body;

    if (!endDate) {
      return res.status(400).json({ error: "End Date is required" });
    }

    // Find the offer
    const offer = await Offer.findById(offerId);
    if (!offer) {
      return res.status(404).json({ error: "Offer not found" });
    }

    // Make sure only the client who owns this offer can update
    if (offer.clientId.toString() !== req.user.id) {
      return res.status(403).json({ error: "Not authorized" });
    }

    // Update endDate
    offer.endDate = endDate;
    await offer.save();

    return res.status(200).json({ message: "End Date updated successfully", endDate });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Server error" });
  }
});

module.exports = router;
